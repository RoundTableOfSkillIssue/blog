<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Pwn 101: Buffer Overflow Part 1 | RToSI</title>
<meta name="keywords" content="pwn, 101">
<meta name="description" content="Buffer Overflow là gì? Điều gì gây nên lỗi tràn bộ đệm? Làm sao để khai thác?">
<meta name="author" content="Lio">
<link rel="canonical" href="https://roundtableofskillissue.github.io/blog/sharing/pwn101/buffer_overflow/buf1/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://roundtableofskillissue.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://roundtableofskillissue.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://roundtableofskillissue.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://roundtableofskillissue.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://roundtableofskillissue.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Pwn 101: Buffer Overflow Part 1" />
<meta property="og:description" content="Buffer Overflow là gì? Điều gì gây nên lỗi tràn bộ đệm? Làm sao để khai thác?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://roundtableofskillissue.github.io/blog/sharing/pwn101/buffer_overflow/buf1/" /><meta property="article:section" content="sharing" />
<meta property="article:published_time" content="2023-04-30T00:00:00+07:00" />
<meta property="article:modified_time" content="2023-04-30T00:00:00+07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Pwn 101: Buffer Overflow Part 1"/>
<meta name="twitter:description" content="Buffer Overflow là gì? Điều gì gây nên lỗi tràn bộ đệm? Làm sao để khai thác?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Sharings",
      "item": "https://roundtableofskillissue.github.io/blog/sharing/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Pwn 101: Buffer Overflow Part 1",
      "item": "https://roundtableofskillissue.github.io/blog/sharing/pwn101/buffer_overflow/buf1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Pwn 101: Buffer Overflow Part 1",
  "name": "Pwn 101: Buffer Overflow Part 1",
  "description": "Buffer Overflow là gì? Điều gì gây nên lỗi tràn bộ đệm? Làm sao để khai thác?",
  "keywords": [
    "pwn",  101 
  ],
  "articleBody": "Disclaimer Series Pwn 101 này tôi viết cho vui trong lúc rảnh nhằm mục đích chia sẻ lại mấy cái kiến thức mà tôi học được (hoặc tự tôi hiểu được nó là như thế) cũng như kinh nghiệm từ khi mới bắt đầu theo mảng Pwnable cho đến giờ. Mấy cái mớ trong này chưa chắc đã đúng hết 100% nhưng nếu thấy không vừa mắt thì cứ coi như là tôi viết linh tinh rồi tắt tab này đi là được.\nBuffer Overflow là gì? Well, theo như con ChatGpt nó gen cho tôi thì, để chép nguyên văn luôn.\nLỗi buffer overflow là một lỗi bảo mật phổ biến trong các ứng dụng máy tính, đặc biệt là trong các chương trình được viết bằng các ngôn ngữ lập trình thấp như C và C++. Nó xảy ra khi một chương trình cố gắng ghi vào một vùng nhớ đệm (buffer) vượt quá kích thước đã cấp phát cho nó, gây ra việc ghi đè dữ liệu vào vùng nhớ khác trong bộ nhớ hoặc thậm chí là tràn ra ngoài vùng nhớ của chương trình, gây ra lỗi hoặc crash chương trình. Nói chung là, chương trình nó cho bạn cái vùng nhớ rộng 10 bytes, nhưng không nói là bạn được viết bao nhiêu byte, thế là bạn viết cmn 11 bytes hay thậm chí 69420 bytes nó vẫn lấy hết và điều này gây ra lỗi.\nLỗi Buffer Overflow (tràn bộ đệm) là một trong những lỗi chương trình phổ biến mà các pwner thường khai thác, và cùng là nền tảng cho những kỹ thuật pwn phức tạp như ret2shell, ret2libc, ROP, …\nĐịnh vị Buffer Overflow như thế nào? Cái này thì vô số biến thể luôn, nhưng chung quy lại thì vẫn là chương trình nó cho phép bạn ghi vào một cái vùng nhớ nhiều dữ liệu hơn mức cái vùng nhớ đó chứa được. Để dễ tiếp cận hơn một cách cơ bản thì hãy cùng xem qua ví dụ sau.\n#include void main() { int num = 0; char buffer[10]; gets(buffer); return 0; } Một đoạn code C trông có vẻ vô hại. Chương trình này khai báo một biến num kiểu int có giá trị bằng 0 và một biến buffer là dãy 10 ký tự kiểu char. Sau đó chương trình tiến hành lấy chuỗi input từ người dùng nhập vào biến ‘buffer’ và kết thúc chương trình mà không làm gì cả.\nNhưng nếu chương trình thật sự làm gì đó thì sao? Hãy modify cái chương trình này lại một xíu nhé.\n#include void main() { int num = 0; char buffer[10]; gets(buffer); if(num != 0) { puts(\"Wait... How?!\"); } return 0; } Tại đây ta thấy, sau khi chương trình nhận vào input của người dùng bỏ vào biến buffer thì sẽ kiểm tra giá trị của biến num xem có khác giá trị 0 hay không. Trong suốt quá trình chạy chương trình, ta không hề thực hiện bất kỳ một tác vụ nào làm thay đổi biến num nên xét theo lẽ thường, điều kiện if không thể đạt được.\nVấn đề đặt ra ở đây là liệu có cách nào để thay đổi biến num khi chạy chương trình trên hay không? Câu trả lời là có.\nMemory Layout trên kiến trúc Intel Thông thường, trong kiểu kiến trúc intel x86, các biến local của hàm khi khai báo sẽ được lưu vào trong vùng nhớ stack, và khi ta compile chương trình bằng gcc, các biến có kiểu dữ liệu kích thước cố định sẽ được ưu tiên xếp ở dưới.\nThêm một điều nữa, vì intel x86 là kiểu kiến trúc Little Endian nên ngoại trừ các chuỗi ký tự, khi chương trình tiến hành đọc hay lưu dữ liệu tại địa chỉ của vùng nhớ bất kỳ thì các byte giá trị sẽ được xếp ngược lại. Tức là nếu địa chỉ chứa một biến có kiểu dữ liệu int (4 bytes) đang hiển thị là 0x04030201 thì các byte của nó có thứ tự là 01 02 03 04.\nVậy nên theo như các biến ta đã khai báo như trên thì vùng nhớ sẽ cơ bản được thiết lập như sau:\nbắt đầu của buffer | V | 00 00 | kết thúc | 00 00 00 00 | của buffer -\u003e | 00 00 00 00 | | 00 00 00 00 | \u003c- kết thúc của num ^ | bắt đầu của num Do đó ta có thể thấy, khác với địa chỉ bắt đầu của chuỗi buffer là nằm ở trên cùng và đọc dần xuống dưới cuối theo thứ tự từ trái sang phải, khi ta đọc biến num thì chương trình sẽ tự hiểu và đọc ngược các byte từ cuối về đầu, tức là từ trái sang phải. Đừng hỏi tôi, cái memory nó xếp như vậy tôi đâu có thiết kế mấy cái củ shit này.\nÔng nào học môn Kiến trúc máy tính xong có khi sẽ hiểu sơ sơ cái này còn không thì tạm thời cứ cho là như vậy trước đi.\nViệc nguy hiểm khi sử dụng hàm không có bảo vệ Quay trở lại vấn đề chính, đầu tiên hãy nhìn vào Linux Programmer’s Manual dành cho hàm gets. Ta biết được rằng hàm gets đọc một dòng từ stdin vào bộ đệm (buffer) được trỏ tới bởi tham số con trỏ s và dừng lại cho đến khi gặp ký tự xuống dòng (‘\\n’) hoặc ký tự EOF (End of File). Không những thế, ta con nhận được một dòng cảnh báo được gạch chân rất rõ ràng: “Đừng bao giờ sử dụng hàm này.”\nGETS(3) Linux Programmer's Manual GETS(3) NAME gets - get a string from standard input (DEPRECATED) SYNOPSIS #include char *gets(char *s); DESCRIPTION Never use this function. gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\\0'). No check for buffer overrun is performed (see BUGS below). RETURN VALUE gets() returns s on success, and NULL on error or when end of file occurs while no characters have been read. However, given the lack of buffer overrun checking, there can be no guarantees that the function will even return. BUGS Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. Bản chất của hàm gets là đọc vào chuỗi ký tự từ người dùng hoặc từ file, tuy nhiên nó lại không hề kiểm tra số lượng ký tự mà nó nhận vào. Chính do đó mà cho đến khi chưa gặp ký tự xuống dòng hoặc EOF thì nó vẫn sẽ tiếp tục đọc, và điều này dẫn đến một lỗi vô cùng phổ biến đó chính là Buffer Overflow.\nKhai thác Buffer Overflow để thay đổi biến local Giả sử ta nhập vào một chuỗi 10 ký tự ‘a’ (mã hex 0x61). Hàm gets đọc vào chuỗi này và tiến hành lưu vào trong vùng nhớ từ bắt đầu của biến buffer cho đến kết thúc của biến buffer, vừa vặn 10 bytes. Mọi thứ diễn ra như bình thường, chương trình chạy đúng như những gì chúng ta dự đoán lúc trước và không có điều gì kỳ lạ xảy ra cả.\nLúc này vùng nhớ của ta sẽ như sau:\nbắt đầu của buffer | V | 61 61 | kết thúc | 61 61 61 61 | của buffer -\u003e | 61 61 61 61 | | 00 00 00 00 | \u003c- kết thúc của num ^ | bắt đầu của num Nhưng nếu ta nhập vào chuỗi 11 ký tự ‘a’ thì sao?\nHàm gets vẫn sẽ nhận vào chuỗi 11 ký tự đó, tiến hành lưu vào vùng nhớ từ bắt đầu của biến buffer cho đến kết thúc của biến buffer, nhưng độ dài vùng nhớ của biến này chỉ có 10 bytes. Câu hỏi đặt ra là: byte thứ 11 sẽ đi về đâu?\nCâu trả lời chính là nó sẽ tràn xuống vùng nhớ ở dưới, không đâu khác chính là vùng nhớ của biến num.\nbắt đầu của buffer | V | 61 61 | kết thúc | 61 61 61 61 | của buffer -\u003e | 61 61 61 61 | | 00 00 00 61 | \u003c- kết thúc của num ^ | bắt đầu của num Vậy khi này nếu như chương trình tiến hành đọc dữ liệu của biến num thì nó sẽ không còn mang giá trị 0 như ban đầu nữa mà lại là 0x61 (hay 0x00000061), tức bằng 97. Ta đã có thể thay đổi được giá trị của biến num và điều chỉnh được luồng thực thi của chương trình.\n$ ./test aaaaaaaaaaa Wait... How?! Nếu nhập vào nhiều ký tự hơn nữa, ta không những có thể ghi đè lên biến num mà còn tiếp tục ghi đè xuống được vùng nhớ ở dưới biến num. Nhưng vấn đề này sẽ được đè cập tới ở phần tiếp theo, trong một kỹ thuật khác bắt nguồn từ việc khai thác lỗi Buffer Overflow này.\nMột lưu ý nho nhỏ, là đối với các phiên bản gcc mới hơn, compiler sẽ luôn ưu tiên đặt các biến buffer ở vùng địa chỉ cao hơn các biến riêng lẻ khác (tức là nằm ở dưới trong stack) vậy nên việc ghi đè lên biến num như ví dụ trên sẽ không còn khả thi nữa.\nTrên thực tế, không chỉ mỗi hàm gets mà còn có nhiều những hàm khác có thể gây nên lỗi tràn bộ đệm. Và việc tràn bộ đệm này có thể giúp các attacker thay đổi được luồng thực thi của chương trình, và hơn nữa là chiếm được shell của hệ thống.\n",
  "wordCount" : "1701",
  "inLanguage": "en",
  "datePublished": "2023-04-30T00:00:00+07:00",
  "dateModified": "2023-04-30T00:00:00+07:00",
  "author":[{
    "@type": "Person",
    "name": "Lio"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://roundtableofskillissue.github.io/blog/sharing/pwn101/buffer_overflow/buf1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "RToSI",
    "logo": {
      "@type": "ImageObject",
      "url": "https://roundtableofskillissue.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://roundtableofskillissue.github.io/blog/" accesskey="h" title="RToSI (Alt + H)">RToSI</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://roundtableofskillissue.github.io/blog/sharing/" title="Sharing">
                    <span>Sharing</span>
                </a>
            </li>
            <li>
                <a href="https://roundtableofskillissue.github.io/blog/writeup/" title="Writeups">
                    <span>Writeups</span>
                </a>
            </li>
            <li>
                <a href="https://roundtableofskillissue.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://roundtableofskillissue.github.io/blog/member/" title="Members">
                    <span>Members</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Pwn 101: Buffer Overflow Part 1
    </h1>
    <div class="post-meta"><span title='2023-04-30 00:00:00 +0700 +0700'>April 30, 2023</span>&nbsp;·&nbsp;Lio

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#disclaimer" aria-label="Disclaimer">Disclaimer</a></li>
                <li>
                    <a href="#buffer-overflow-l%c3%a0-g%c3%ac" aria-label="Buffer Overflow là gì?">Buffer Overflow là gì?</a></li>
                <li>
                    <a href="#%c4%91%e1%bb%8bnh-v%e1%bb%8b-buffer-overflow-nh%c6%b0-th%e1%ba%bf-n%c3%a0o" aria-label="Định vị Buffer Overflow như thế nào?">Định vị Buffer Overflow như thế nào?</a></li>
                <li>
                    <a href="#memory-layout-tr%c3%aan-ki%e1%ba%bfn-tr%c3%bac-intel" aria-label="Memory Layout trên kiến trúc Intel">Memory Layout trên kiến trúc Intel</a></li>
                <li>
                    <a href="#vi%e1%bb%87c-nguy-hi%e1%bb%83m-khi-s%e1%bb%ad-d%e1%bb%a5ng-h%c3%a0m-kh%c3%b4ng-c%c3%b3-b%e1%ba%a3o-v%e1%bb%87" aria-label="Việc nguy hiểm khi sử dụng hàm không có bảo vệ">Việc nguy hiểm khi sử dụng hàm không có bảo vệ</a></li>
                <li>
                    <a href="#khai-th%c3%a1c-buffer-overflow-%c4%91%e1%bb%83-thay-%c4%91%e1%bb%95i-bi%e1%ba%bfn-local" aria-label="Khai thác Buffer Overflow để thay đổi biến local">Khai thác Buffer Overflow để thay đổi biến local</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="disclaimer">Disclaimer<a hidden class="anchor" aria-hidden="true" href="#disclaimer">#</a></h2>
<p>Series <strong>Pwn 101</strong> này tôi viết cho vui trong lúc rảnh nhằm mục đích chia sẻ lại mấy cái kiến thức mà tôi học được (hoặc tự tôi hiểu được nó là như thế) cũng như kinh nghiệm từ khi mới bắt đầu theo mảng Pwnable cho đến giờ. Mấy cái mớ trong này chưa chắc đã đúng hết 100% nhưng nếu thấy không vừa mắt thì cứ coi như là tôi viết linh tinh rồi tắt tab này đi là được.</p>
<h2 id="buffer-overflow-là-gì">Buffer Overflow là gì?<a hidden class="anchor" aria-hidden="true" href="#buffer-overflow-là-gì">#</a></h2>
<p>Well, theo như con ChatGpt nó gen cho tôi thì, để chép nguyên văn luôn.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Lỗi buffer overflow là một lỗi bảo mật phổ biến trong các ứng dụng máy tính, đặc biệt là trong các chương trình được viết bằng các ngôn ngữ lập trình thấp như C và C++. Nó xảy ra khi một chương trình cố gắng ghi vào một vùng nhớ đệm (buffer) vượt quá kích thước đã cấp phát cho nó, gây ra việc ghi đè dữ liệu vào vùng nhớ khác trong bộ nhớ hoặc thậm chí là tràn ra ngoài vùng nhớ của chương trình, gây ra lỗi hoặc crash chương trình.
</span></span></code></pre></div><p>Nói chung là, chương trình nó cho bạn cái vùng nhớ rộng 10 bytes, nhưng không nói là bạn được viết bao nhiêu byte, thế là bạn viết cmn 11 bytes hay thậm chí 69420 bytes nó vẫn lấy hết và điều này gây ra lỗi.</p>
<p>Lỗi Buffer Overflow (tràn bộ đệm) là một trong những lỗi chương trình phổ biến mà các pwner thường khai thác, và cùng là nền tảng cho những kỹ thuật pwn phức tạp như ret2shell, ret2libc, ROP, &hellip;</p>
<h2 id="định-vị-buffer-overflow-như-thế-nào">Định vị Buffer Overflow như thế nào?<a hidden class="anchor" aria-hidden="true" href="#định-vị-buffer-overflow-như-thế-nào">#</a></h2>
<p>Cái này thì vô số biến thể luôn, nhưng chung quy lại thì vẫn là chương trình nó cho phép bạn ghi vào một cái vùng nhớ nhiều dữ liệu hơn mức cái vùng nhớ đó chứa được. Để dễ tiếp cận hơn một cách cơ bản thì hãy cùng xem qua ví dụ sau.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gets</span>(buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Một đoạn code C trông có vẻ vô hại. Chương trình này khai báo một biến <code>num</code> kiểu int có giá trị bằng 0 và một biến <code>buffer</code> là dãy 10 ký tự kiểu char. Sau đó chương trình tiến hành lấy chuỗi input từ người dùng nhập vào biến ‘buffer’ và kết thúc chương trình mà không làm gì cả.</p>
<p>Nhưng nếu chương trình thật sự làm gì đó thì sao? Hãy modify cái chương trình này lại một xíu nhé.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gets</span>(buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(num <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Wait... How?!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Tại đây ta thấy, sau khi chương trình nhận vào input của người dùng bỏ vào biến <code>buffer</code> thì sẽ kiểm tra giá trị của biến <code>num</code> xem có khác giá trị 0 hay không. Trong suốt quá trình chạy chương trình, ta không hề thực hiện bất kỳ một tác vụ nào làm thay đổi biến <code>num</code> nên xét theo lẽ thường, điều kiện if không thể đạt được.</p>
<p>Vấn đề đặt ra ở đây là liệu có cách nào để thay đổi biến <code>num</code> khi chạy chương trình trên hay không? Câu trả lời là có.</p>
<h2 id="memory-layout-trên-kiến-trúc-intel">Memory Layout trên kiến trúc Intel<a hidden class="anchor" aria-hidden="true" href="#memory-layout-trên-kiến-trúc-intel">#</a></h2>
<p>Thông thường, trong kiểu kiến trúc intel x86, các biến local của hàm khi khai báo sẽ được lưu vào trong vùng nhớ stack, và khi ta compile chương trình bằng gcc, các biến có kiểu dữ liệu kích thước cố định sẽ được ưu tiên xếp ở dưới.</p>
<p>Thêm một điều nữa, vì intel x86 là kiểu kiến trúc Little Endian nên ngoại trừ các chuỗi ký tự, khi chương trình tiến hành đọc hay lưu dữ liệu tại địa chỉ của vùng nhớ bất kỳ thì các byte giá trị sẽ được xếp ngược lại. Tức là nếu địa chỉ chứa một biến có kiểu dữ liệu int (4 bytes) đang hiển thị là 0x04030201 thì các byte của nó có thứ tự là 01 02 03 04.</p>
<p>Vậy nên theo như các biến ta đã khai báo như trên thì vùng nhớ sẽ cơ bản được thiết lập như sau:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>                bắt đầu của buffer
</span></span><span style="display:flex;"><span>                      |
</span></span><span style="display:flex;"><span>                      V
</span></span><span style="display:flex;"><span>                | 00 00       |
</span></span><span style="display:flex;"><span>   kết thúc     | 00 00 00 00 |
</span></span><span style="display:flex;"><span>  của buffer -&gt; | 00 00 00 00 |
</span></span><span style="display:flex;"><span>                | 00 00 00 00 | &lt;- kết thúc của num
</span></span><span style="display:flex;"><span>                  ^
</span></span><span style="display:flex;"><span>                  |
</span></span><span style="display:flex;"><span>            bắt đầu của num
</span></span></code></pre></div><p>Do đó ta có thể thấy, khác với địa chỉ bắt đầu của chuỗi <code>buffer</code> là nằm ở trên cùng và đọc dần xuống dưới cuối theo thứ tự từ trái sang phải, khi ta đọc biến <code>num</code> thì chương trình sẽ tự hiểu và đọc ngược các byte từ cuối về đầu, tức là từ trái sang phải. Đừng hỏi tôi, cái memory nó xếp như vậy tôi đâu có thiết kế mấy cái củ shit này.</p>
<p>Ông nào học môn Kiến trúc máy tính xong có khi sẽ hiểu sơ sơ cái này còn không thì tạm thời cứ cho là như vậy trước đi.</p>
<h2 id="việc-nguy-hiểm-khi-sử-dụng-hàm-không-có-bảo-vệ">Việc nguy hiểm khi sử dụng hàm không có bảo vệ<a hidden class="anchor" aria-hidden="true" href="#việc-nguy-hiểm-khi-sử-dụng-hàm-không-có-bảo-vệ">#</a></h2>
<p>Quay trở lại vấn đề chính, đầu tiên hãy nhìn vào Linux Programmer’s Manual dành cho hàm <strong>gets</strong>. Ta biết được rằng hàm <strong>gets</strong> đọc một dòng từ stdin vào bộ đệm (buffer) được trỏ tới bởi tham số con trỏ s và dừng lại cho đến khi gặp ký tự xuống dòng (‘\n’) hoặc ký tự EOF (End of File). Không những thế, ta con nhận được một dòng cảnh báo được gạch chân rất rõ ràng: “Đừng bao giờ sử dụng hàm này.”</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>GETS(3)                 Linux Programmer&#39;s Manual                GETS(3)
</span></span><span style="display:flex;"><span>NAME
</span></span><span style="display:flex;"><span>       gets - get a string from standard input (DEPRECATED)
</span></span><span style="display:flex;"><span>SYNOPSIS
</span></span><span style="display:flex;"><span>       #include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       char *gets(char *s);
</span></span><span style="display:flex;"><span>DESCRIPTION
</span></span><span style="display:flex;"><span>       Never use this function.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       gets() reads a line from stdin into the buffer pointed to by s
</span></span><span style="display:flex;"><span>       until either a terminating newline or EOF, which it replaces with
</span></span><span style="display:flex;"><span>       a null byte (&#39;\0&#39;).  No check for buffer overrun is performed
</span></span><span style="display:flex;"><span>       (see BUGS below).
</span></span><span style="display:flex;"><span>RETURN VALUE
</span></span><span style="display:flex;"><span>       gets() returns s on success, and NULL on error or when end of
</span></span><span style="display:flex;"><span>       file occurs while no characters have been read.  However, given
</span></span><span style="display:flex;"><span>       the lack of buffer overrun checking, there can be no guarantees
</span></span><span style="display:flex;"><span>       that the function will even return.
</span></span><span style="display:flex;"><span>BUGS
</span></span><span style="display:flex;"><span>       Never use gets().  Because it is impossible to tell without
</span></span><span style="display:flex;"><span>       knowing the data in advance how many characters gets() will read,
</span></span><span style="display:flex;"><span>       and because gets() will continue to store characters past the end
</span></span><span style="display:flex;"><span>       of the buffer, it is extremely dangerous to use.  It has been
</span></span><span style="display:flex;"><span>       used to break computer security.  Use fgets() instead.
</span></span></code></pre></div><p>Bản chất của hàm <strong>gets</strong> là đọc vào chuỗi ký tự từ người dùng hoặc từ file, tuy nhiên nó lại không hề kiểm tra số lượng ký tự mà nó nhận vào. Chính do đó mà cho đến khi chưa gặp ký tự xuống dòng hoặc EOF thì nó vẫn sẽ tiếp tục đọc, và điều này dẫn đến một lỗi vô cùng phổ biến đó chính là Buffer Overflow.</p>
<h2 id="khai-thác-buffer-overflow-để-thay-đổi-biến-local">Khai thác Buffer Overflow để thay đổi biến local<a hidden class="anchor" aria-hidden="true" href="#khai-thác-buffer-overflow-để-thay-đổi-biến-local">#</a></h2>
<p>Giả sử ta nhập vào một chuỗi 10 ký tự ‘a’ (mã hex 0x61). Hàm <strong>gets</strong> đọc vào chuỗi này và tiến hành lưu vào trong vùng nhớ từ bắt đầu của biến <code>buffer</code> cho đến kết thúc của biến <code>buffer</code>, vừa vặn 10 bytes. Mọi thứ diễn ra như bình thường, chương trình chạy đúng như những gì chúng ta dự đoán lúc trước và không có điều gì kỳ lạ xảy ra cả.</p>
<p>Lúc này vùng nhớ của ta sẽ như sau:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>                bắt đầu của buffer
</span></span><span style="display:flex;"><span>                      |
</span></span><span style="display:flex;"><span>                      V
</span></span><span style="display:flex;"><span>                | 61 61       |
</span></span><span style="display:flex;"><span>   kết thúc     | 61 61 61 61 |
</span></span><span style="display:flex;"><span>  của buffer -&gt; | 61 61 61 61 |
</span></span><span style="display:flex;"><span>                | 00 00 00 00 | &lt;- kết thúc của num
</span></span><span style="display:flex;"><span>                  ^
</span></span><span style="display:flex;"><span>                  |
</span></span><span style="display:flex;"><span>            bắt đầu của num
</span></span></code></pre></div><p>Nhưng nếu ta nhập vào chuỗi 11 ký tự ‘a’ thì sao?</p>
<p>Hàm <strong>gets</strong> vẫn sẽ nhận vào chuỗi 11 ký tự đó, tiến hành lưu vào vùng nhớ từ bắt đầu của biến <code>buffer</code> cho đến kết thúc của biến <code>buffer</code>, nhưng độ dài vùng nhớ của biến này chỉ có 10 bytes. Câu hỏi đặt ra là: byte thứ 11 sẽ đi về đâu?</p>
<p>Câu trả lời chính là nó sẽ tràn xuống vùng nhớ ở dưới, không đâu khác chính là vùng nhớ của biến <code>num</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>                bắt đầu của buffer
</span></span><span style="display:flex;"><span>                      |
</span></span><span style="display:flex;"><span>                      V
</span></span><span style="display:flex;"><span>                | 61 61       |
</span></span><span style="display:flex;"><span>   kết thúc     | 61 61 61 61 |
</span></span><span style="display:flex;"><span>  của buffer -&gt; | 61 61 61 61 |
</span></span><span style="display:flex;"><span>                | 00 00 00 61 | &lt;- kết thúc của num
</span></span><span style="display:flex;"><span>                  ^
</span></span><span style="display:flex;"><span>                  |
</span></span><span style="display:flex;"><span>            bắt đầu của num
</span></span></code></pre></div><p>Vậy khi này nếu như chương trình tiến hành đọc dữ liệu của biến <code>num</code> thì nó sẽ không còn mang giá trị 0 như ban đầu nữa mà lại là 0x61 (hay 0x00000061), tức bằng 97. Ta đã có thể thay đổi được giá trị của biến <code>num</code> và điều chỉnh được luồng thực thi của chương trình.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./test
</span></span><span style="display:flex;"><span>aaaaaaaaaaa
</span></span><span style="display:flex;"><span>Wait... How?!
</span></span></code></pre></div><p>Nếu nhập vào nhiều ký tự hơn nữa, ta không những có thể ghi đè lên biến <code>num</code> mà còn tiếp tục ghi đè xuống được vùng nhớ ở dưới biến <code>num</code>. Nhưng vấn đề này sẽ được đè cập tới ở phần tiếp theo, trong một kỹ thuật khác bắt nguồn từ việc khai thác lỗi Buffer Overflow này.</p>
<p>Một lưu ý nho nhỏ, là đối với các phiên bản gcc mới hơn, compiler sẽ luôn ưu tiên đặt các biến buffer ở vùng địa chỉ cao hơn các biến riêng lẻ khác (tức là nằm ở dưới trong stack) vậy nên việc ghi đè lên biến <code>num</code> như ví dụ trên sẽ không còn khả thi nữa.</p>
<p>Trên thực tế, không chỉ mỗi hàm <strong>gets</strong> mà còn có nhiều những hàm khác có thể gây nên lỗi tràn bộ đệm. Và việc tràn bộ đệm này có thể giúp các attacker thay đổi được luồng thực thi của chương trình, và hơn nữa là chiếm được shell của hệ thống.</p>
<!-- raw HTML omitted -->


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://roundtableofskillissue.github.io/blog/tags/pwn/">pwn</a></li>
      <li><a href="https://roundtableofskillissue.github.io/blog/tags/101/">101</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://roundtableofskillissue.github.io/blog/">RToSI</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
